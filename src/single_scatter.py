import numpy as np
import pandas as pd
import os


class SingleScatteringSimulation:
    """
    The `SingleScatteringSimulation` class simulates scattering events in a stellar
    environment characterized by a variety of phase functions, albedos, and angles.
    The simulation uses Henyey-Greenstein phase function to compute light scattering.

    Parameters:
    ----
    path_to_flux_data_file : str
        The filepath to the CSV file containing stellar flux data.
    path_to_dust_density_data_dir : str
        The filepath to the directory containing dust density data.
    path_to_save_scattered_flux_array : str
        The filepath to save the scattered flux array generated by the simulate() method.
    wavelengths : list or np.ndarray
        The list or array of wavelengths (in meters) to be considered in the simulation.
    sigma_at_wavelength : list or np.ndarray
        The list or array of cross-section values (in square meters) at corresponding wavelengths.
    nangle : int
        The number of angles (in radians) to be used in the simulation.
    nalbedo : int
        The number of different albedo values to be considered in the simulation.
    nphase : int
        The number of different phase function values to be considered in the simulation.
    verbose : bool, optional
        If set to True, the simulation will print detailed information during execution.
    """

    def __init__(
        self,
        path_to_flux_data_file: str,
        path_to_dust_density_data_dir: str,
        path_to_save_scattered_flux_array: str,
        wavelengths: list[float] | np.ndarray[float],
        sigma_at_wavelength: list | np.ndarray,
        nangle: int,
        nalbedo: int,
        nphase: int,
        verbose: bool = False,
    ):
        if not os.path.isfile(path_to_flux_data_file):
            raise FileNotFoundError(f"No such file: {path_to_flux_data_file}")

        if len(wavelengths) != len(sigma_at_wavelength):
            raise ValueError(
                "wavelengths and sigma_at_wavelength must have the same length"
            )

        # Initialising Attributes
        self.path_to_flux_data_file = path_to_flux_data_file
        self.path_to_dust_density_data_dir = path_to_dust_density_data_dir
        self.path_to_save_scattered_flux_array = path_to_save_scattered_flux_array
        self.nangle = nangle
        self.nalbedo = nalbedo
        self.nphase = nphase
        self.verbose = verbose
        self.wavelengths = wavelengths
        self.sigma_at_wavelength = sigma_at_wavelength

        # Load flux data (Castelli - Kurucz) from file
        self.flux_data = pd.read_csv(self.path_to_flux_data_file)
        self.n_stars = len(self.flux_data)

        # Set up parameters and arrays for simulation
        self.nwave = len(self.wavelengths)
        self.dsun = np.linspace(0, 2000, 99)
        self.angle = np.arange(self.nangle) * 0.1
        self.flux = np.zeros((self.nwave, self.nangle, self.nalbedo, self.nphase))

    def henyey_greenstein(self, albedo: float, phase: float, angle: float):
        """
        Compute the Henyey-Greenstein phase function, which describes the distribution
        of light scattered in a particular direction.

        Parameters:
        ----
        albedo : float
            The albedo of the particles. Ranges between 0 (no reflectivity)
            and 1 (total reflectivity).
        phase : float
            The phase function 'g' value, which describes the directional distribution
            of scattered light. Ranges from -1 (backscattering) to 1 (forward scattering).
        angle : float
            The scattering angle, in radians.

        Returns:
        ----
        float
            The calculated Henyey-Greenstein phase function value.
        """
        if not (0 <= albedo <= 1):
            raise ValueError("Albedo must be between 0 and 1")

        if not (-1 <= phase <= 1):
            raise ValueError("Phase 'g' must be between -1 and 1")

        numerator = 1 - (phase**2)
        denominator = (1 + (phase**2) - (2 * phase * np.cos(angle))) ** (3 / 2)

        return (albedo / (4 * np.pi)) * (numerator / denominator)

    def single_scatter(
        self,
        dust: list | np.ndarray,
        dsun: np.ndarray,
        dstar: float,
        sflux: float,
        sigma: float,
        albedo: float,
        phase: float,
        angle: float,
    ) -> float:
        """
        Perform a single scattering simulation. This simulates the scattering of light from
        a star off of a dust particle and calculates the flux as a result of this event.

        Parameters:
        ----
        dust : list or np.ndarray
            The dust density values along the line of sight.
        dsun : np.ndarray
            The distances from the sun for each dust density value.
        dstar : float
            The distance to the star.
        sflux : float
            The stellar flux value.
        sigma : float
            The cross-section value at the given wavelength.
        albedo : float
            The albedo, or scattering coefficient, of the particles.
        phase : float
            The phase function, which describes the directional distribution of scattered light.
        angle : float
            The angle between the star's sightline and the sightline of a given concentric circle around the star.

        Returns:
        ----
        float
            The calculated flux resulting from the scattering events.
        """
        angle_in_radians = np.deg2rad(angle)
        cos_angle_in_radians = np.cos(angle_in_radians)
        sin_angle_in_radians = np.sin(angle_in_radians)

        delta_dist = dsun[1] - dsun[0]
        min_dist = sin_angle_in_radians * dstar
        dist = np.sqrt((dsun - dstar * cos_angle_in_radians) ** 2 + min_dist**2)
        dangle = np.arcsin(min_dist / dist)
        minpos = np.argmin(dist)  # minpos - index of min value of dist
        if minpos > len(dangle):
            dangle[minpos + 1 :] = np.pi - np.asin(min_dist / dist[minpos + 1 :])

        # Henyey - Greenstein Phase Function

        sca = self.henyey_greenstein(albedo, phase, dangle)

        flux = (sflux / (4.0 * np.pi * dist**2)) * sca

        delta_dist *= 3.08e18
        nflux = len(flux)
        for i in range(nflux):
            flux[i] = flux[i] * np.exp(-sigma * np.sum(dust[0:i]) * delta_dist)

        return np.sum(flux)

    def _save_flux(self, star: str):
        """
        Save the calculated flux array to a numpy file.

        Parameters:
            star (str): The identifier of the star, used for naming the saved file.
        """
        filename = os.path.join(self.path_to_save_scattered_flux_array, f"{star}.npy")
        np.save(filename, self.flux)
        if self.verbose:
            print(f"Saved flux for star {star} to {filename}")

    def _calculate_flux_for_star(
        self, sflux: np.ndarray, dust: np.ndarray, dstar: float
    ):
        """
        Calculate the flux for a given star across all configured parameters.

        Parameters:
            sflux (np.ndarray): The stellar flux values for different wavelengths.
            dust (np.ndarray): The dust density values along the line of sight.
            dstar (float): The distance to the star.
        """
        for iwave, wavelength in enumerate(self.wavelengths):
            if self.verbose:
                print(f"-- Wavelength: {wavelength}")
            for ialbedo in range(self.nalbedo):
                albedo = float(ialbedo) / 10.0
                for iphase in range(self.nphase):
                    phase = float(iphase) / 10.0
                    for iangle in range(self.nangle):
                        self.flux[iwave, iangle, ialbedo, iphase] = self.single_scatter(
                            dust,
                            self.dsun,
                            dstar,
                            sflux[iwave],
                            self.sigma_at_wavelength[iwave],
                            albedo,
                            phase,
                            self.angle[iangle],
                        )

    def simulate(self):
        """
        Perform the single scattering simulation for all stars in the input file and for all
        wavelengths, angles, albedos, and phase functions. The resulting flux arrays are saved
        to .npy files.
        """
        for _, row in self.flux_data.iterrows():
            self.flux = np.zeros((self.nwave, self.nangle, self.nalbedo, self.nphase))

            star = str(int(row["Star"]))
            if self.verbose:
                print(f"Star: {star}")

            dust_density_data = np.loadtxt(
                os.path.join(self.path_to_dust_density_data_dir, f"{star}.csv"),
                skiprows=1,
            )
            dust = dust_density_data[:, 2]

            dstar = row["Distance(pc)"]
            sflux = row.filter(regex=("Flux.*")).values

            self._calculate_flux_for_star(sflux, dust, dstar)

            if self.verbose:
                print(f"Size of Flux: {self.flux.shape}")

            self._save_flux(star)


if __name__ == "__main__":
    from dotenv import load_dotenv

    load_dotenv()
    DATA = os.environ.get("DATA")

    path_to_flux_data_file = os.path.join(DATA, "flux_data_m8.csv")
    path_to_dust_density_data_dir = os.path.join(DATA, "dust_data_green_2019")
    path_to_save_scattered_flux_array = os.path.join(DATA, "single_scatter_model")
    wavelengths = [1100, 1500, 2300]
    sigma_at_wavelength = np.array([1.840, 1.275, 1.439])  # Extinction Cross Section
    sigma_at_wavelength *= 1e-21
    sigma_at_wavelength = sigma_at_wavelength * 3.08e18
    nangle = 100
    nalbedo = 10
    nphase = 10

    single_scatter_object = SingleScatteringSimulation(
        path_to_flux_data_file,
        path_to_dust_density_data_dir,
        path_to_save_scattered_flux_array,
        wavelengths,
        sigma_at_wavelength,
        nangle,
        nalbedo,
        nphase,
        verbose=True,
    )

    single_scatter_object.simulate()
